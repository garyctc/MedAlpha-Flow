import { mkdir, readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import { pathToFileURL } from "node:url";

type DesignTokens = {
  colors: {
    semantic: Record<string, { value: string }>;
    primitives: Record<string, Record<string, string>>;
  };
  borderRadius: Record<string, { value: string }>;
  shadows: Record<string, { value: string }>;
  animation: {
    duration: Record<string, string>;
    easing: Record<string, string>;
  };
  touchTargets: Record<string, string>;
};

function assertHexColor(value: string, label: string) {
  if (!/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(value)) {
    throw new Error(`Expected ${label} to be hex color, got: ${value}`);
  }
}

function hexToRgb(hex: string) {
  const raw = hex.replace("#", "");
  const normalized =
    raw.length === 3
      ? raw
          .split("")
          .map((c) => c + c)
          .join("")
      : raw;
  const int = Number.parseInt(normalized, 16);
  return {
    r: (int >> 16) & 0xff,
    g: (int >> 8) & 0xff,
    b: int & 0xff,
  };
}

function rgbToHslTriplet({ r, g, b }: { r: number; g: number; b: number }) {
  const rn = r / 255;
  const gn = g / 255;
  const bn = b / 255;

  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  const delta = max - min;

  let h = 0;
  let s = 0;
  const l = (max + min) / 2;

  if (delta !== 0) {
    s = delta / (1 - Math.abs(2 * l - 1));
    switch (max) {
      case rn:
        h = ((gn - bn) / delta) % 6;
        break;
      case gn:
        h = (bn - rn) / delta + 2;
        break;
      default:
        h = (rn - gn) / delta + 4;
    }
    h *= 60;
    if (h < 0) h += 360;
  }

  const hRounded = Math.round(h);
  const sRounded = Math.round(s * 100);
  const lRounded = Math.round(l * 100);
  return `${hRounded} ${sRounded}% ${lRounded}%`;
}

function hexToHslTriplet(hex: string) {
  return rgbToHslTriplet(hexToRgb(hex));
}

function parseMs(value: string, label: string) {
  const match = /^(\d+(?:\.\d+)?)ms$/.exec(value);
  if (!match) throw new Error(`Expected ${label} to be ms string, got: ${value}`);
  return Number(match[1]);
}

function parseCubicBezier(value: string, label: string) {
  const match =
    /^cubic-bezier\(\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*\)$/.exec(
      value,
    );
  if (!match) throw new Error(`Expected ${label} to be cubic-bezier, got: ${value}`);
  return [Number(match[1]), Number(match[2]), Number(match[3]), Number(match[4])] as const;
}

function getRequiredHex(tokens: DesignTokens, label: string, value: string | undefined) {
  if (!value) throw new Error(`Missing required token: ${label}`);
  assertHexColor(value, label);
  return value;
}

async function loadTokens(tokensPath: string): Promise<DesignTokens> {
  const raw = await readFile(tokensPath, "utf-8");
  return JSON.parse(raw) as DesignTokens;
}

function buildCss(tokens: DesignTokens) {
  const semantic = tokens.colors.semantic;
  const primitives = tokens.colors.primitives;

  const background = getRequiredHex(tokens, "colors.semantic.background.value", semantic.background?.value);
  const foreground = getRequiredHex(tokens, "colors.semantic.foreground.value", semantic.foreground?.value);
  const card = getRequiredHex(tokens, "colors.semantic.backgroundCard.value", semantic.backgroundCard?.value);

  const border = getRequiredHex(tokens, "colors.semantic.border.value", semantic.border?.value);
  const ring = getRequiredHex(tokens, "colors.semantic.ring.value", semantic.ring?.value);

  const primary = getRequiredHex(tokens, "colors.semantic.primary.value", semantic.primary?.value);
  const primaryForeground = "#FFFFFF";

  const destructive = getRequiredHex(tokens, "colors.semantic.secondary.value", semantic.secondary?.value);
  const destructiveForeground = "#FFFFFF";

  const success = getRequiredHex(tokens, "colors.semantic.success.value", semantic.success?.value) ?? "#16A34A";
  const warning = getRequiredHex(tokens, "colors.semantic.warning.value", semantic.warning?.value) ?? "#F59E0B";

  const mutedForeground = getRequiredHex(
    tokens,
    "colors.semantic.foregroundMuted.value",
    semantic.foregroundMuted?.value,
  );

  const gray20 = getRequiredHex(tokens, "colors.primitives.gray.20", primitives.gray?.["20"]);
  const blue10 = getRequiredHex(tokens, "colors.primitives.blue.10", primitives.blue?.["10"]);

  const radiusSm = tokens.borderRadius.sm?.value ?? "8px";
  const radiusMd = tokens.borderRadius.md?.value ?? "12px";
  const radiusLg = tokens.borderRadius.lg?.value ?? "16px";
  const radiusXl = tokens.borderRadius.xl?.value ?? "20px";

  const shadowSoft = tokens.shadows.soft?.value ?? "0 1px 3px rgba(0,0,0,0.06)";
  const shadowCard = tokens.shadows.card?.value ?? "0 2px 8px rgba(0,0,0,0.08)";
  const shadowElevated = tokens.shadows.elevated?.value ?? "0 4px 16px rgba(0,0,0,0.12)";

  const lines = [
    "/* Generated by script/generate-design-tokens.ts. Do not edit by hand. */",
    "",
    ":root {",
    `  --background: ${hexToHslTriplet(background)};`,
    `  --foreground: ${hexToHslTriplet(foreground)};`,
    "",
    `  --card: ${hexToHslTriplet(card)};`,
    `  --card-foreground: ${hexToHslTriplet(foreground)};`,
    "",
    `  --popover: ${hexToHslTriplet(card)};`,
    `  --popover-foreground: ${hexToHslTriplet(foreground)};`,
    "",
    `  --border: ${hexToHslTriplet(border)};`,
    `  --input: ${hexToHslTriplet(border)};`,
    `  --ring: ${hexToHslTriplet(ring)};`,
    "",
    `  --primary: ${hexToHslTriplet(primary)};`,
    `  --primary-foreground: ${hexToHslTriplet(primaryForeground)};`,
    "",
    `  --secondary: ${hexToHslTriplet(gray20)};`,
    `  --secondary-foreground: ${hexToHslTriplet(foreground)};`,
    "",
    `  --muted: ${hexToHslTriplet(gray20)};`,
    `  --muted-foreground: ${hexToHslTriplet(mutedForeground)};`,
    "",
    `  --accent: ${hexToHslTriplet(blue10)};`,
    `  --accent-foreground: ${hexToHslTriplet(primaryForeground)};`,
    "",
    `  --destructive: ${hexToHslTriplet(destructive)};`,
    `  --destructive-foreground: ${hexToHslTriplet(destructiveForeground)};`,
    "",
    `  --success: ${hexToHslTriplet(success)};`,
    `  --success-foreground: ${hexToHslTriplet(primaryForeground)};`,
    "",
    `  --warning: ${hexToHslTriplet(warning)};`,
    `  --warning-foreground: ${hexToHslTriplet(primaryForeground)};`,
    "",
    `  --radius: ${radiusMd};`,
    `  --radius-sm: ${radiusSm};`,
    `  --radius-md: ${radiusMd};`,
    `  --radius-lg: ${radiusLg};`,
    `  --radius-xl: ${radiusXl};`,
    "",
    `  --shadow-soft: ${shadowSoft};`,
    `  --shadow-card: ${shadowCard};`,
    `  --shadow-elevated: ${shadowElevated};`,
    "}",
    "",
  ];
  return lines.join("\n");
}

function buildTs(tokens: DesignTokens) {
  const duration = tokens.animation.duration;
  const easing = tokens.animation.easing;

  const durationFastMs = parseMs(duration.fast, "animation.duration.fast");
  const durationDefaultMs = parseMs(duration.default, "animation.duration.default");
  const durationSlowMs = parseMs(duration.slow, "animation.duration.slow");
  const easingDefaultCss = easing.default;
  const easingDefaultBezier = parseCubicBezier(easingDefaultCss, "animation.easing.default");

  const touchTargetsMinimum = tokens.touchTargets.minimum;
  const touchTargetsComfortable = tokens.touchTargets.comfortable;

  const lines = [
    "/* Generated by script/generate-design-tokens.ts. Do not edit by hand. */",
    "",
    "export const TOKENS = {",
    "  animation: {",
    "    durationMs: {",
    `      fast: ${durationFastMs},`,
    `      default: ${durationDefaultMs},`,
    `      slow: ${durationSlowMs},`,
    "    },",
    "    easing: {",
    `      defaultCss: ${JSON.stringify(easingDefaultCss)},`,
    `      defaultBezier: ${JSON.stringify(easingDefaultBezier)},`,
    "    },",
    "  },",
  "  shadows: {",
    `    soft: ${JSON.stringify(tokens.shadows.soft?.value ?? "")},`,
    `    card: ${JSON.stringify(tokens.shadows.card?.value ?? "")},`,
    `    elevated: ${JSON.stringify(tokens.shadows.elevated?.value ?? "")},`,
  "  },",
    "  touchTargets: {",
    `    minimum: ${JSON.stringify(touchTargetsMinimum)},`,
    `    comfortable: ${JSON.stringify(touchTargetsComfortable)},`,
    "  },",
  "} as const;",
    "",
    "export type Tokens = typeof TOKENS;",
    "",
  ];
  return lines.join("\n");
}

export async function generateDesignTokens() {
  const tokensPath = path.join(process.cwd(), "shared", "design-tokens.json");
  const outCssPath = path.join(process.cwd(), "client", "src", "styles", "tokens.css");
  const outTsPath = path.join(process.cwd(), "client", "src", "styles", "tokens.ts");

  const tokens = await loadTokens(tokensPath);

  await mkdir(path.dirname(outCssPath), { recursive: true });
  await mkdir(path.dirname(outTsPath), { recursive: true });

  await writeFile(outCssPath, buildCss(tokens), "utf-8");
  await writeFile(outTsPath, buildTs(tokens), "utf-8");
}

if (process.argv[1] && import.meta.url === pathToFileURL(process.argv[1]).href) {
  generateDesignTokens().catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
